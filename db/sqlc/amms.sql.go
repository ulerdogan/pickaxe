// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: amms.sql

package db

import (
	"context"
)

const createAmm = `-- name: CreateAmm :one
INSERT INTO amms (
  dex_name,
  router_address,
  key,
  algorithm_type
) VALUES (
  $1, $2, $3, $4
) RETURNING amm_id, dex_name, router_address, key, algorithm_type, created_at
`

type CreateAmmParams struct {
	DexName       string `json:"dex_name"`
	RouterAddress string `json:"router_address"`
	Key           string `json:"key"`
	AlgorithmType string `json:"algorithm_type"`
}

func (q *Queries) CreateAmm(ctx context.Context, arg CreateAmmParams) (Amm, error) {
	row := q.db.QueryRowContext(ctx, createAmm,
		arg.DexName,
		arg.RouterAddress,
		arg.Key,
		arg.AlgorithmType,
	)
	var i Amm
	err := row.Scan(
		&i.AmmID,
		&i.DexName,
		&i.RouterAddress,
		&i.Key,
		&i.AlgorithmType,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAmm = `-- name: DeleteAmm :exec
DELETE FROM amms
WHERE amm_id = $1
`

func (q *Queries) DeleteAmm(ctx context.Context, ammID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAmm, ammID)
	return err
}

const getAllAmms = `-- name: GetAllAmms :many
SELECT amm_id, dex_name, router_address, key, algorithm_type, created_at FROM amms
ORDER BY amm_id
`

func (q *Queries) GetAllAmms(ctx context.Context) ([]Amm, error) {
	rows, err := q.db.QueryContext(ctx, getAllAmms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Amm{}
	for rows.Next() {
		var i Amm
		if err := rows.Scan(
			&i.AmmID,
			&i.DexName,
			&i.RouterAddress,
			&i.Key,
			&i.AlgorithmType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAmmByDEX = `-- name: GetAmmByDEX :many
SELECT amm_id, dex_name, router_address, key, algorithm_type, created_at FROM amms
WHERE dex_name = $1
ORDER BY dex_name
`

func (q *Queries) GetAmmByDEX(ctx context.Context, dexName string) ([]Amm, error) {
	rows, err := q.db.QueryContext(ctx, getAmmByDEX, dexName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Amm{}
	for rows.Next() {
		var i Amm
		if err := rows.Scan(
			&i.AmmID,
			&i.DexName,
			&i.RouterAddress,
			&i.Key,
			&i.AlgorithmType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAmmById = `-- name: GetAmmById :one
SELECT amm_id, dex_name, router_address, key, algorithm_type, created_at FROM amms
WHERE amm_id = $1 LIMIT 1
`

func (q *Queries) GetAmmById(ctx context.Context, ammID int64) (Amm, error) {
	row := q.db.QueryRowContext(ctx, getAmmById, ammID)
	var i Amm
	err := row.Scan(
		&i.AmmID,
		&i.DexName,
		&i.RouterAddress,
		&i.Key,
		&i.AlgorithmType,
		&i.CreatedAt,
	)
	return i, err
}

const getAmmKeys = `-- name: GetAmmKeys :many
SELECT DISTINCT key FROM amms
WHERE key IS NOT NULL AND key != ''
ORDER BY KEY
`

func (q *Queries) GetAmmKeys(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAmmKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeys = `-- name: GetKeys :many
SELECT DISTINCT key FROM amms
ORDER BY key
`

func (q *Queries) GetKeys(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
