// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: pools.sql

package db

import (
	"context"
	"database/sql"
)

const createPool = `-- name: CreatePool :one
INSERT INTO pools (
  address,
  amm_id,
  token_a,
  token_b
) VALUES (
  $1, $2, $3, $4
) RETURNING pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block
`

type CreatePoolParams struct {
	Address string `json:"address"`
	AmmID   int64  `json:"amm_id"`
	TokenA  string `json:"token_a"`
	TokenB  string `json:"token_b"`
}

func (q *Queries) CreatePool(ctx context.Context, arg CreatePoolParams) (Pool, error) {
	row := q.db.QueryRowContext(ctx, createPool,
		arg.Address,
		arg.AmmID,
		arg.TokenA,
		arg.TokenB,
	)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}

const deletePool = `-- name: DeletePool :exec
DELETE FROM pools
WHERE pool_id = $1
`

func (q *Queries) DeletePool(ctx context.Context, poolID int64) error {
	_, err := q.db.ExecContext(ctx, deletePool, poolID)
	return err
}

const getAllPools = `-- name: GetAllPools :many
SELECT pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block FROM pools
ORDER BY pool_id
`

func (q *Queries) GetAllPools(ctx context.Context) ([]Pool, error) {
	rows, err := q.db.QueryContext(ctx, getAllPools)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pool{}
	for rows.Next() {
		var i Pool
		if err := rows.Scan(
			&i.PoolID,
			&i.Address,
			&i.AmmID,
			&i.TokenA,
			&i.TokenB,
			&i.ReserveA,
			&i.ReserveB,
			&i.Fee,
			&i.TotalValue,
			&i.ExtraData,
			&i.GeneralExtraData,
			&i.LastUpdated,
			&i.LastBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPoolsWithoutKeys = `-- name: GetAllPoolsWithoutKeys :many
SELECT pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block FROM pools
WHERE amm_id IN 
(SELECT amm_id FROM amms WHERE key = '')
ORDER BY pool_id
`

func (q *Queries) GetAllPoolsWithoutKeys(ctx context.Context) ([]Pool, error) {
	rows, err := q.db.QueryContext(ctx, getAllPoolsWithoutKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pool{}
	for rows.Next() {
		var i Pool
		if err := rows.Scan(
			&i.PoolID,
			&i.Address,
			&i.AmmID,
			&i.TokenA,
			&i.TokenB,
			&i.ReserveA,
			&i.ReserveB,
			&i.Fee,
			&i.TotalValue,
			&i.ExtraData,
			&i.GeneralExtraData,
			&i.LastUpdated,
			&i.LastBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPoolByAddress = `-- name: GetPoolByAddress :one
SELECT pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block FROM pools
WHERE address = $1 LIMIT 1
`

func (q *Queries) GetPoolByAddress(ctx context.Context, address string) (Pool, error) {
	row := q.db.QueryRowContext(ctx, getPoolByAddress, address)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}

const getPoolByAddressExtra = `-- name: GetPoolByAddressExtra :one
SELECT pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block FROM pools
WHERE address = $1 AND extra_data=$2 LIMIT 1
`

type GetPoolByAddressExtraParams struct {
	Address   string         `json:"address"`
	ExtraData sql.NullString `json:"extra_data"`
}

func (q *Queries) GetPoolByAddressExtra(ctx context.Context, arg GetPoolByAddressExtraParams) (Pool, error) {
	row := q.db.QueryRowContext(ctx, getPoolByAddressExtra, arg.Address, arg.ExtraData)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}

const getPoolsByAmm = `-- name: GetPoolsByAmm :many
SELECT pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block FROM pools
WHERE amm_id = $1
ORDER BY address
`

func (q *Queries) GetPoolsByAmm(ctx context.Context, ammID int64) ([]Pool, error) {
	rows, err := q.db.QueryContext(ctx, getPoolsByAmm, ammID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pool{}
	for rows.Next() {
		var i Pool
		if err := rows.Scan(
			&i.PoolID,
			&i.Address,
			&i.AmmID,
			&i.TokenA,
			&i.TokenB,
			&i.ReserveA,
			&i.ReserveB,
			&i.Fee,
			&i.TotalValue,
			&i.ExtraData,
			&i.GeneralExtraData,
			&i.LastUpdated,
			&i.LastBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPoolsByPair = `-- name: GetPoolsByPair :many
SELECT pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block FROM pools
WHERE token_a = $1 AND token_b = $2
ORDER BY amm_id
`

type GetPoolsByPairParams struct {
	TokenA string `json:"token_a"`
	TokenB string `json:"token_b"`
}

func (q *Queries) GetPoolsByPair(ctx context.Context, arg GetPoolsByPairParams) ([]Pool, error) {
	rows, err := q.db.QueryContext(ctx, getPoolsByPair, arg.TokenA, arg.TokenB)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pool{}
	for rows.Next() {
		var i Pool
		if err := rows.Scan(
			&i.PoolID,
			&i.Address,
			&i.AmmID,
			&i.TokenA,
			&i.TokenB,
			&i.ReserveA,
			&i.ReserveB,
			&i.Fee,
			&i.TotalValue,
			&i.ExtraData,
			&i.GeneralExtraData,
			&i.LastUpdated,
			&i.LastBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPoolsByToken = `-- name: GetPoolsByToken :many
SELECT pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block FROM pools
WHERE token_a = $1 OR token_b = $1
ORDER BY amm_id
`

func (q *Queries) GetPoolsByToken(ctx context.Context, tokenA string) ([]Pool, error) {
	rows, err := q.db.QueryContext(ctx, getPoolsByToken, tokenA)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pool{}
	for rows.Next() {
		var i Pool
		if err := rows.Scan(
			&i.PoolID,
			&i.Address,
			&i.AmmID,
			&i.TokenA,
			&i.TokenB,
			&i.ReserveA,
			&i.ReserveB,
			&i.Fee,
			&i.TotalValue,
			&i.ExtraData,
			&i.GeneralExtraData,
			&i.LastUpdated,
			&i.LastBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePoolExtraData = `-- name: UpdatePoolExtraData :one
UPDATE pools
SET extra_data = $2
WHERE pool_id = $1
RETURNING pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block
`

type UpdatePoolExtraDataParams struct {
	PoolID    int64          `json:"pool_id"`
	ExtraData sql.NullString `json:"extra_data"`
}

func (q *Queries) UpdatePoolExtraData(ctx context.Context, arg UpdatePoolExtraDataParams) (Pool, error) {
	row := q.db.QueryRowContext(ctx, updatePoolExtraData, arg.PoolID, arg.ExtraData)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}

const updatePoolFee = `-- name: UpdatePoolFee :one
UPDATE pools
SET fee = $2
WHERE pool_id = $1
RETURNING pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block
`

type UpdatePoolFeeParams struct {
	PoolID int64  `json:"pool_id"`
	Fee    string `json:"fee"`
}

func (q *Queries) UpdatePoolFee(ctx context.Context, arg UpdatePoolFeeParams) (Pool, error) {
	row := q.db.QueryRowContext(ctx, updatePoolFee, arg.PoolID, arg.Fee)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}

const updatePoolGeneralExtraData = `-- name: UpdatePoolGeneralExtraData :one
UPDATE pools
SET general_extra_data = $2, last_block = $3, last_updated = NOW()
WHERE pool_id = $1
RETURNING pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block
`

type UpdatePoolGeneralExtraDataParams struct {
	PoolID           int64          `json:"pool_id"`
	GeneralExtraData sql.NullString `json:"general_extra_data"`
	LastBlock        int64          `json:"last_block"`
}

func (q *Queries) UpdatePoolGeneralExtraData(ctx context.Context, arg UpdatePoolGeneralExtraDataParams) (Pool, error) {
	row := q.db.QueryRowContext(ctx, updatePoolGeneralExtraData, arg.PoolID, arg.GeneralExtraData, arg.LastBlock)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}

const updatePoolReserves = `-- name: UpdatePoolReserves :one
UPDATE pools
SET reserve_a = $2, reserve_b = $3, last_block = $4, last_updated = NOW()
WHERE pool_id = $1
RETURNING pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block
`

type UpdatePoolReservesParams struct {
	PoolID    int64  `json:"pool_id"`
	ReserveA  string `json:"reserve_a"`
	ReserveB  string `json:"reserve_b"`
	LastBlock int64  `json:"last_block"`
}

func (q *Queries) UpdatePoolReserves(ctx context.Context, arg UpdatePoolReservesParams) (Pool, error) {
	row := q.db.QueryRowContext(ctx, updatePoolReserves,
		arg.PoolID,
		arg.ReserveA,
		arg.ReserveB,
		arg.LastBlock,
	)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}

const updatePoolReservesWithExtraData = `-- name: UpdatePoolReservesWithExtraData :one
UPDATE pools
SET extra_data = $2, last_block = $3, last_updated = NOW()
WHERE pool_id = $1
RETURNING pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block
`

type UpdatePoolReservesWithExtraDataParams struct {
	PoolID    int64          `json:"pool_id"`
	ExtraData sql.NullString `json:"extra_data"`
	LastBlock int64          `json:"last_block"`
}

func (q *Queries) UpdatePoolReservesWithExtraData(ctx context.Context, arg UpdatePoolReservesWithExtraDataParams) (Pool, error) {
	row := q.db.QueryRowContext(ctx, updatePoolReservesWithExtraData, arg.PoolID, arg.ExtraData, arg.LastBlock)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}

const updatePoolTV = `-- name: UpdatePoolTV :one
UPDATE pools
SET total_value = $2
WHERE pool_id = $1
RETURNING pool_id, address, amm_id, token_a, token_b, reserve_a, reserve_b, fee, total_value, extra_data, general_extra_data, last_updated, last_block
`

type UpdatePoolTVParams struct {
	PoolID     int64  `json:"pool_id"`
	TotalValue string `json:"total_value"`
}

func (q *Queries) UpdatePoolTV(ctx context.Context, arg UpdatePoolTVParams) (Pool, error) {
	row := q.db.QueryRowContext(ctx, updatePoolTV, arg.PoolID, arg.TotalValue)
	var i Pool
	err := row.Scan(
		&i.PoolID,
		&i.Address,
		&i.AmmID,
		&i.TokenA,
		&i.TokenB,
		&i.ReserveA,
		&i.ReserveB,
		&i.Fee,
		&i.TotalValue,
		&i.ExtraData,
		&i.GeneralExtraData,
		&i.LastUpdated,
		&i.LastBlock,
	)
	return i, err
}
